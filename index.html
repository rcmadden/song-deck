<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <script defer data-domain="rcmadden.github.io/song-deck" src="https://plausible.io/js/script.js"></script>
    <title>Song Deck</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="playlist-dropdown">
                <button class="playlist-btn" id="playlistBtn">
                    <h1>My Deck</h1>
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M4 6l4 4 4-4" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                    </svg>
                </button>
                <div class="playlist-panel" id="playlistPanel">
                    <a href="#" class="playlist-option" data-playlist="my-deck">My Deck</a>
                    <a href="#" class="playlist-option" data-playlist="8-track">8-Track</a>
                </div>
            </div>
            <div class="header-icons">
                <button class="theme-toggle" title="Toggle theme" id="themeToggle">
                    <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M10 2V4M10 16V18M4 10H2M6.31 6.31L4.93 4.93M13.69 6.31L15.07 4.93M6.31 13.69L4.93 15.07M13.69 13.69L15.07 15.07M18 10H16M13 10A3 3 0 1 1 7 10A3 3 0 0 1 13 10Z" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                    </svg>
                </button>
                <div class="account-dropdown">
                    <div class="account-section" title="Account">
                        <div class="account-icon">
                            <svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <circle cx="16" cy="16" r="15" stroke="currentColor" stroke-width="2"/>
                                <circle cx="16" cy="12" r="4" stroke="currentColor" stroke-width="2"/>
                                <path d="M8 24c0-4.4 3.6-8 8-8s8 3.6 8 8" stroke="currentColor" stroke-width="2"/>
                            </svg>
                        </div>
                        <div class="account-name">Russia M</div>
                    </div>
                    <div class="account-panel" id="accountPanel">
                        <div class="account-option" id="profileOption">Profile</div>
                        <div class="account-option" id="billingOption">Billing</div>
                        <div class="account-option" id="themeOption">Light mode</div>
                        <div class="account-option" id="logoutOption">Log out</div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="controls">
            <div class="active-filters" id="activeFilters">
                <!-- Filter pills will be populated by JavaScript -->
            </div>
            <div class="filter-dropdown">
                <button class="filter-btn" id="filterBtn" title="Filter">
                    <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M3 6h14M6 10h8M8 14h4" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                    </svg>
                </button>
                <div class="filter-panel" id="filterPanel">
                    <select id="filterKey" class="filter-select">
                        <option value="">All Keys</option>
                    </select>
                    <select id="filterArtist" class="filter-select">
                        <option value="">All Artists</option>
                    </select>
                    <select id="filterYear" class="filter-select">
                        <option value="">All Years</option>
                    </select>
                    <select id="filterEmA" class="filter-select">
                        <option value="">All Em&A</option>
                    </select>
                    <input type="text" id="searchSong" placeholder="Search songs..." class="filter-input">
                    <button id="clearFilters" class="clear-filters-btn">Clear All Filters</button>
                </div>
            </div>
        </div>
        
        <div class="main-content">
            <table id="songTable">
                <thead>
                    <tr>
                        <th class="sortable" data-sort="card"><span role="img" aria-label="Playing card">üÉè</span> <span class="sort-indicator">‚Üï</span></th>
                        <th class="sortable" data-sort="song">Song <span class="sort-indicator">‚Üï</span></th>
                        <th><span role="img" aria-label="Puzzle piece">üß©</span></th>
                        <th class="sortable" data-sort="key">üîë Key <span class="sort-indicator">‚Üï</span></th>
                    </tr>
                </thead>
                <tbody id="songTableBody">
                    <!-- Table rows will be populated by JavaScript -->
                </tbody>
            </table>
            
            <div id="detailCard" class="detail-card hidden">
                <!-- Card details will be populated by JavaScript -->
            </div>
        </div>
    </div>

    <script type="module">
        // Import filter functions
        import { applyFilters, createFilterCriteria } from './filters.js';
        // This will store our song data
        let songData = [];
        let filteredData = [];
        let sortColumn = null;
        let sortDirection = 'asc';
        let currentPlaylist = 'my-deck';
        let activeFilters = {};

        // MVC Model
        class Model {
            constructor() {
                this.songs = [];
                this.playlists = [];
            }

            async loadData() {
                try {
                    const [songsResponse, playlistsResponse] = await Promise.all([
                        fetch('songDB.csv'),
                        fetch('data/playlists.json')
                    ]);

                    if (!songsResponse.ok) throw new Error('Failed to load songDB.csv');
                    if (!playlistsResponse.ok) throw new Error('Failed to load data/playlists.json');

                    const csvText = await songsResponse.text();
                    this.playlists = await playlistsResponse.json();

                    const parsed = Papa.parse(csvText, {
                        header: true,
                        skipEmptyLines: true,
                        dynamicTyping: true
                    });

                                        

                    if (parsed.errors.length) {
                        parsed.errors.forEach(error => {
                            console.warn(`CSV parsing warning on row ${error.row}: ${error.message}`);
                        });
                    }
                    this.songs = parsed.data;
                    
                    return this;
                } catch (error) {
                    console.error('Error loading application data:', error);
                    throw error;
                }
            }

            getPlaylists() {
                return this.playlists;
            }

            getSongsForPlaylist(playlistId) {
                const playlist = this.playlists.find(p => p.id === playlistId);
                if (!playlist) {
                    console.warn(`Playlist with id "${playlistId}" not found.`);
                    return [];
                }

                const playlistSongs = this.songs.filter(song => {
                    const songPlaylists = song.Playlists || '';
                    return songPlaylists.includes(playlist.name);
                });

                if (playlist.type === 'ordered-list') {
                    const getOrder = (song) => {
                        const orderData = (song.PlaylistOrders || '').split(',');
                        const playlistOrder = orderData.find(o => o.startsWith(playlist.id + ':'));
                        if (!playlistOrder) return 999;
                        return parseFloat(playlistOrder.split(':')[1]) || 999;
                    };
                    return playlistSongs.sort((a, b) => getOrder(a) - getOrder(b));

                } else if (playlist.type === 'deck' && playlist.sortKey) {
                    return playlistSongs.sort((a, b) => {
                        const aOrder = parseInt(a.DeckOrder) || 999;
                        const bOrder = parseInt(b.DeckOrder) || 999;
                        return aOrder - bOrder;
                    });
                }

                return playlistSongs;
            }
        }
        const model = new Model();

        /**
         * SongDeckManager - Manages dual-index system with computed properties
         * Separates song identity from presentation order (derived from DeckOrder).
         */
        class SongDeckManager {
            constructor() {
                this.positionCache = new Map();
            }

            buildPositionMap(playlistId) {
                const cacheKey = playlistId;
                if (this.positionCache.has(cacheKey)) {
                    return this.positionCache.get(cacheKey);
                }

                const playlistSongs = model.getSongsForPlaylist(playlistId);
                const positionMap = new Map(
                    playlistSongs.map((song, idx) => [song.songId, idx + 1])
                );

                this.positionCache.set(cacheKey, positionMap);
                return positionMap;
            }

            getSongDisplay(song, playlistId) {
                const positionMap = this.buildPositionMap(playlistId);
                const arrayPosition = positionMap.get(song.songId); // For ordered lists
                const playlist = model.getPlaylists().find(p => p.id === playlistId);

                if (playlist && playlist.type === 'deck') {
                    const deckOrder = parseInt(song.DeckOrder) || null;

                    // Handle invalid or missing DeckOrder by showing a Joker.
                    if (!deckOrder || deckOrder <= 0 || deckOrder > 52) {
                        return {
                            position: null,
                            suit: 'üÉè',
                            card: '',
                            display: 'üÉè'
                        };
                    }

                    const suit = this.getSuit(deckOrder);
                    const cardValue = this._getCardValue(deckOrder);

                    return {
                        position: deckOrder,
                        suit: suit,
                        card: cardValue,
                        display: `${suit} ${cardValue}`
                    };
                } else {
                    // For other list types (like 8-track).
                    return {
                        position: arrayPosition,
                        suit: null,
                        card: null,
                        display: `${arrayPosition || ''}`
                    };
                }
            }

            _getCardValue(deckOrder) {
                // This assumes deckOrder is a valid number between 1 and 52.
                const value = (deckOrder - 1) % 13 + 1;
                if (value === 1) return 'A';
                if (value === 11) return 'J';
                if (value === 12) return 'Q';
                if (value === 13) return 'K';
                return String(value);
            }

            getSuit(deckPosition) {
                if (!deckPosition || deckPosition <= 0) return 'üÉè';
                if (deckPosition <= 13) return '‚ô£Ô∏è';
                if (deckPosition <= 26) return '‚ô¶Ô∏è';
                if (deckPosition <= 39) return '‚ô†Ô∏è';
                return '‚ô•Ô∏è';
            }

            invalidateCache(playlistId = null) {
                if (playlistId) {
                    this.positionCache.delete(playlistId);
                } else {
                    this.positionCache.clear();
                }
            }
        }

        // Initialize deck manager (will be set after CSV loads)
        let deckManager = null;

        // Theme management
        function initializeTheme() {
            const savedTheme = localStorage.getItem('theme') || 'light';
            document.documentElement.setAttribute('data-theme', savedTheme);
            updateThemeIcon(savedTheme);
            updateAccountThemeOption(savedTheme);
        }

        function toggleTheme() {
            const currentTheme = document.documentElement.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            document.documentElement.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
            updateThemeIcon(newTheme);
            updateAccountThemeOption(newTheme);
        }

        function updateThemeIcon(theme) {
            const themeButton = document.getElementById('themeToggle');
            const icon = theme === 'dark' ? 
                `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M17.293 13.293A8 8 0 0 1 6.707 2.707a8.001 8.001 0 1 0 10.586 10.586z" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                </svg>` :
                `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M10 2V4M10 16V18M4 10H2M6.31 6.31L4.93 4.93M13.69 6.31L15.07 4.93M6.31 13.69L4.93 15.07M13.69 13.69L15.07 15.07M18 10H16M13 10A3 3 0 1 1 7 10A3 3 0 0 1 13 10Z" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                </svg>`;
            themeButton.innerHTML = icon;
        }

        function updateAccountThemeOption(theme) {
            const themeOption = document.getElementById('themeOption');
            if (themeOption) {
                themeOption.textContent = theme === 'dark' ? 'Light mode' : 'Dark mode';
            }
        }

        // Account dropdown functionality
        function setupAccountDropdown() {
            const accountSection = document.querySelector('.account-section');
            const accountPanel = document.getElementById('accountPanel');
            
            if (accountSection && accountPanel) {
                accountSection.addEventListener('click', (e) => {
                    e.stopPropagation();
                    accountPanel.style.display = accountPanel.style.display === 'block' ? 'none' : 'block';
                });
                
                accountPanel.addEventListener('click', (e) => {
                    e.stopPropagation();
                });
                
                document.getElementById('profileOption')?.addEventListener('click', () => {
                    alert('Profile functionality coming soon!');
                    accountPanel.style.display = 'none';
                });
                
                document.getElementById('billingOption')?.addEventListener('click', () => {
                    alert('Billing functionality coming soon!');
                    accountPanel.style.display = 'none';
                });
                
                document.getElementById('themeOption')?.addEventListener('click', () => {
                    toggleTheme();
                    accountPanel.style.display = 'none';
                });
                
                document.getElementById('logoutOption')?.addEventListener('click', () => {
                    alert('Logout functionality coming soon!');
                    accountPanel.style.display = 'none';
                });
            }
        }

        // Filter pill management
        function renderActiveFilters() {
            const activeFiltersContainer = document.getElementById('activeFilters');
            if (!activeFiltersContainer) return;
            
            activeFiltersContainer.innerHTML = '';
            
            Object.entries(activeFilters).forEach(([key, value]) => {
                if (value) {
                    const pill = document.createElement('div');
                    pill.className = 'filter-pill';
                    
                    const filterName = key === 'searchSong' ? 'Search' : 
                                      key === 'filterKey' ? 'Key' :
                                      key === 'filterArtist' ? 'Artist' :
                                      key === 'filterYear' ? 'Year' :
                                      key === 'filterEmA' ? 'Em&A' : key;
                    
                    pill.innerHTML = `
                        <span>${filterName}: ${value}</span>
                        <button class="remove-filter" onclick="removeFilter('${key}')">√ó</button>
                    `;
                    
                    activeFiltersContainer.appendChild(pill);
                }
            });
        }

        function removeFilter(filterKey) {
            const element = document.getElementById(filterKey);
            if (element) {
                element.value = '';
                activeFilters[filterKey] = '';
                filterData();
                renderActiveFilters();
            }
        }
        
        // Make removeFilter globally accessible
        window.removeFilter = removeFilter;



        // Function to convert notes text to clickable links
        function convertNotesToLinks(notesText) {
            if (!notesText || typeof notesText !== 'string') return '';

            // Robustly split by comma, then trim whitespace from each part.
            const parts = notesText.split(',');
            const linkElements = [];

            parts.forEach(part => {
                const trimmedPart = part.trim();
                if (!trimmedPart) return; // Skip empty parts (e.g., from a trailing comma)

                const isLink = trimmedPart.startsWith('http') || /\.(pdf|md|png|jpg|jpeg|gif|svg)$/i.test(trimmedPart);

                if (isLink) {
                    const filename = trimmedPart.split('/').pop();
                    const displayName = filename.replace(/\.[^/.]+$/, "").replace(/[_-]/g, ' ');
                    linkElements.push(`<li><a href="#" onclick="handleLinkClick(event); loadDocument('${trimmedPart}', '${filename}'); return false;">${displayName}</a></li>`);
                } else {
                    linkElements.push(`<li>${trimmedPart}</li>`);
                }
            });

            if (linkElements.length > 0) {
                return `<ul>${linkElements.join('')}</ul>`;
            }
            return '';
        }

        function handleLinkClick(event) {
        // Remove active state from all links in this card
        document.querySelectorAll('.notes-links a').forEach(link => {
            link.classList.remove('active-link');
        });
        
        // Add active state to clicked link
        event.target.classList.add('active-link');
        }
        
        // Make handleLinkClick globally accessible
        window.handleLinkClick = handleLinkClick;

        // Function to load and display document in the detail card
        function loadDocument(url, filename) {
            const documentViewer = document.getElementById('documentViewer');
            if (!documentViewer) return;
            
            documentViewer.style.display = 'block';
            const fileExtension = filename.split('.').pop().toLowerCase();
            
            if (fileExtension === 'pdf') {
                documentViewer.innerHTML = `<iframe src="${url}" title="${filename}"></iframe>`;
            } else if (['png', 'jpg', 'jpeg', 'gif', 'svg'].includes(fileExtension)) {
                documentViewer.innerHTML = `<img src="${url}" alt="${filename}" />`;
            } else if (fileExtension === 'md') {
                fetch(url)
                    .then(response => response.text())
                    .then(text => {
                        const htmlContent = text
                            .replace(/^# (.*$)/gim, '<h1>$1</h1>')
                            .replace(/^## (.*$)/gim, '<h2>$1</h2>')
                            .replace(/^### (.*$)/gim, '<h3>$1</h3>')
                            .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                            .replace(/\*(.*?)\*/g, '<em>$1</em>')
                            .replace(/\n/g, '<br>');
                        
                        documentViewer.innerHTML = `<div class="markdown-content">${htmlContent}</div>`;
                    })
                    .catch(error => {
                        documentViewer.innerHTML = `<div class="markdown-content">Error loading document: ${error.message}</div>`;
                    });
            } else {
                documentViewer.innerHTML = `<iframe src="${url}" title="${filename}"></iframe>`;
            }
        }
        
        // Make loadDocument globally accessible
        window.loadDocument = loadDocument;

        async function loadSongData() {
            try {
                await model.loadData();
                songData = model.songs; // Keep songData for other parts of the app for now

                // Initialize deck manager with all songs
                deckManager = new SongDeckManager();

                // Set initial playlist and load its songs from the model
                currentPlaylist = 'my-deck';
                filteredData = model.getSongsForPlaylist(currentPlaylist);

                // Initial UI setup
                populateFilters();
                renderSongTable();
                setupEventListeners();
            } catch (error) {
                // Model handles detailed error logging, just update UI
                document.getElementById('songTableBody').innerHTML = `
                    <tr><td colspan="4">‚ö†Ô∏è Error loading application data.</td></tr>`;
            }
        }

        function sortData(column) {
            

            // Step 1: Determine the correct sort direction
            if (sortColumn === column) {
                // If it's the same column, just toggle the direction
                sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                // If it's a new column, set the default direction
                sortColumn = column;
                sortDirection = column === 'card' ? 'desc' : 'asc'; // 'card' starts desc, others asc
            }
            
            // Step 2: Sort the array using clear, readable logic
            filteredData.sort((a, b) => {
                let aVal, bVal;
                
                                if (column === 'card') {
                    if (currentPlaylist === '8-track') {
                        const positionMap = deckManager.buildPositionMap(currentPlaylist);
                        aVal = positionMap.get(a.songId) || 999;
                        bVal = positionMap.get(b.songId) || 999;
                    } else {
                        aVal = parseInt(a.DeckOrder) || 0;
                        bVal = parseInt(b.DeckOrder) || 0;
                    }
                    // Log first comparison to see what's happening
                    
                } else if (column === 'song') {
                                        // For song titles, remove all special characters for a more natural sort.
                    const regex = /[^\p{L}\p{N}\s]/gu;
                    aVal = (a.Title || '').toLowerCase().replace(regex, '');
                    bVal = (b.Title || '').toLowerCase().replace(regex, '');
                } else if (column === 'key') {
                    aVal = (a.Key || '').toLowerCase();
                    bVal = (b.Key || '').toLowerCase();
                } else {
                    return 0;
                }

                if (sortDirection === 'asc') {
                    if (aVal < bVal) return -1;
                    if (aVal > bVal) return 1;
                    return 0;
                } else { // sortDirection is 'desc'
                    if (aVal > bVal) return -1;
                    if (aVal < bVal) return 1;
                    return 0;
                }
            });
            
            // Step 3: Update the UI with the sorted data
            updateSortIndicators();
            renderSongTable();
        }

        function updateSortIndicators() {
            document.querySelectorAll('.sort-indicator').forEach(indicator => {
                indicator.textContent = '‚Üï';
                indicator.style.opacity = '0.5';
            });
            
            if (sortColumn) {
                const activeHeader = document.querySelector(`[data-sort="${sortColumn}"] .sort-indicator`);
                if (activeHeader) {
                    activeHeader.textContent = sortDirection === 'asc' ? '‚Üë' : '‚Üì';
                    activeHeader.style.opacity = '1';
                }
            }
        }

        function populateFilters() {
            const playlistSongs = model.getSongsForPlaylist(currentPlaylist);
            
            const keys = [...new Set(playlistSongs.map(song => song.Key || '').filter(key => key))].sort();
            const artists = [...new Set(playlistSongs.map(song => song.Artist || '').filter(artist => artist))].sort();
            const years = [...new Set(playlistSongs.map(song => String(song.Date || '')).filter(date => date))].sort();
            const emAs = [...new Set(playlistSongs.map(song => song['Em&a'] || '').filter(ema => ema))].sort();
            
            const keySelect = document.getElementById('filterKey');
            if (keySelect) {
                keySelect.innerHTML = '<option value="">All Keys</option>';
                keys.forEach(key => {
                    const option = document.createElement('option');
                    option.value = key;
                    option.textContent = key;
                    keySelect.appendChild(option);
                });
            }
            
            const artistSelect = document.getElementById('filterArtist');
            if (artistSelect) {
                artistSelect.innerHTML = '<option value="">All Artists</option>';
                artists.forEach(artist => {
                    const option = document.createElement('option');
                    option.value = artist;
                    option.textContent = artist;
                    artistSelect.appendChild(option);
                });
            }
            
            const yearSelect = document.getElementById('filterYear');
            if (yearSelect) {
                yearSelect.innerHTML = '<option value="">All Years</option>';
                years.forEach(year => {
                    const option = document.createElement('option');
                    option.value = year;
                    option.textContent = year;
                    yearSelect.appendChild(option);
                });
            }
            
            const emASelect = document.getElementById('filterEmA');
            if (emASelect) {
                emASelect.innerHTML = '<option value="">All Em&A</option>';
                emAs.forEach(ema => {
                    const option = document.createElement('option');
                    option.value = ema;
                    option.textContent = ema;
                    emASelect.appendChild(option);
                });
            }
        }

        function filterData() {
            const filterCriteria = createFilterCriteria();
            
            // Update activeFilters global
            activeFilters = {
                filterKey: filterCriteria.key,
                filterArtist: filterCriteria.artist,
                filterYear: filterCriteria.year,
                filterEmA: filterCriteria.emA,
                searchSong: filterCriteria.search
            };

            // Get the base songs for the current playlist from the model (already sorted).
            const playlistSongs = model.getSongsForPlaylist(currentPlaylist);
            
            // Apply user-selected filters.
            filteredData = applyFilters(playlistSongs, filterCriteria);
            
            renderSongTable();
            renderActiveFilters();
            updateClearButtonStyle();
            hideDetailCardIfFiltered();
        }

        function hideDetailCardIfFiltered() {
            const detailCard = document.getElementById('detailCard');
            if (!detailCard || detailCard.classList.contains('hidden')) return;
            
            // Check if the currently displayed song is still in the filtered results
            const currentSongTitle = detailCard.querySelector('h2')?.textContent;
            const currentSongArtist = detailCard.querySelector('.card-title p')?.textContent;
            
            if (currentSongTitle && currentSongArtist) {
                const songStillVisible = filteredData.some(song => 
                    song.Title === currentSongTitle && song.Artist === currentSongArtist
                );
                
                if (!songStillVisible) {
                    detailCard.classList.add('hidden');
                }
            }
        }

        function hasActiveFilters() {
            return Object.values(activeFilters).some(value => value !== '');
        }

        function updateClearButtonStyle() {
            const clearButton = document.getElementById('clearFilters');
            if (clearButton) {
                if (hasActiveFilters()) {
                    clearButton.classList.add('has-filters');
                } else {
                    clearButton.classList.remove('has-filters');
                }
            }
        }

        function clearAllFilters() {
            document.getElementById('filterKey').value = '';
            document.getElementById('filterArtist').value = '';
            document.getElementById('filterYear').value = '';
            document.getElementById('filterEmA').value = '';
            document.getElementById('searchSong').value = '';
            
            activeFilters = {};
            
            // Reset filteredData to the full, sorted list for the current playlist.
            filteredData = model.getSongsForPlaylist(currentPlaylist);
            
            renderSongTable();
            renderActiveFilters();
            updateClearButtonStyle();
        }

        function setupEventListeners() {
            document.querySelectorAll('.sortable').forEach(header => {
                                header.addEventListener('click', () => {
                    const sortType = header.getAttribute('data-sort');
                    sortData(sortType);
                });
            });
            
            const filterElements = ['filterKey', 'filterArtist', 'filterYear', 'filterEmA'];
            filterElements.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.addEventListener('change', filterData);
                }
            });
            
            const searchElement = document.getElementById('searchSong');
            if (searchElement) {
                searchElement.addEventListener('input', filterData);
            }
            
            const clearFiltersBtn = document.getElementById('clearFilters');
            if (clearFiltersBtn) {
                clearFiltersBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    clearAllFilters();
                });
            }
            
            const filterBtn = document.getElementById('filterBtn');
            const filterPanel = document.getElementById('filterPanel');
            if (filterBtn && filterPanel) {
                filterBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    filterPanel.style.display = filterPanel.style.display === 'block' ? 'none' : 'block';
                });
                
                filterPanel.addEventListener('click', (e) => {
                    e.stopPropagation();
                });
            }
            
            const playlistBtn = document.getElementById('playlistBtn');
            const playlistPanel = document.getElementById('playlistPanel');
            if (playlistBtn && playlistPanel) {
                playlistBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    playlistPanel.style.display = playlistPanel.style.display === 'block' ? 'none' : 'block';
                });
                
                playlistPanel.addEventListener('click', (e) => {
                    e.stopPropagation();
                });
            }
            
            document.querySelectorAll('.playlist-option').forEach(option => {
                option.addEventListener('click', (e) => {
                    e.preventDefault();
                    const playlist = e.target.getAttribute('data-playlist');
                    switchPlaylist(playlist);
                    playlistPanel.style.display = 'none';
                });
            });
            
            const themeToggle = document.getElementById('themeToggle');
            if (themeToggle) {
                themeToggle.addEventListener('click', toggleTheme);
            }
            
            setupAccountDropdown();
            
            document.addEventListener('click', () => {
                if (filterPanel) filterPanel.style.display = 'none';
                if (playlistPanel) playlistPanel.style.display = 'none';
                const accountPanel = document.getElementById('accountPanel');
                if (accountPanel) accountPanel.style.display = 'none';
            });
        }

        function switchPlaylist(playlistId) {
            const playlist = model.getPlaylists().find(p => p.id === playlistId);
            if (!playlist) return;

            const playlistBtn = document.querySelector('.playlist-btn h1');
            playlistBtn.textContent = playlist.name;
            currentPlaylist = playlistId;
            
            // Invalidate the deck manager's cache to ensure positions are re-calculated
            deckManager.invalidateCache(playlistId);

            // Hide detail card when switching playlists
            const detailCard = document.getElementById('detailCard');
            if (detailCard) {
                detailCard.classList.add('hidden');
            }

            // Show/hide controls based on playlist type
            const controls = document.querySelector('.controls');
            if (controls) {
                controls.style.display = playlist.type === 'deck' ? 'flex' : 'none';
            }
            
            // Reset filters and render the new playlist
            clearAllFilters(); // This will now correctly load and render the new playlist
            populateFilters(); // Re-populate filters based on the new song list
        }



        function renderSongTable() {
            const tableBody = document.getElementById('songTableBody');
            if (!tableBody) return;
            
            tableBody.innerHTML = '';
            
            filteredData.forEach((song, index) => {
                if (!song.Title && !song.Artist) return;
                
                const row = document.createElement('tr');
                row.onclick = () => showSongDetails(song);
                
                const clubCell = document.createElement('td');
                clubCell.className = 'club';

                // Use deck manager for computed display
                if (deckManager) {
                    const display = deckManager.getSongDisplay(song, currentPlaylist);
                    clubCell.textContent = display.display;
                } else {
                    // Fallback if manager not initialized
                    clubCell.textContent = `${song.Index} ${song.Card}`;
                }
                row.appendChild(clubCell);
                
                const infoCell = document.createElement('td');
                const songInfo = document.createElement('div');
                songInfo.className = 'song-info';
                
                // const titleDiv = document.createElement('div');
                // titleDiv.className = 'song-title';
                // titleDiv.textContent = song.Title || '';
                // songInfo.appendChild(titleDiv);
                
                // const artistDiv = document.createElement('div');
                // artistDiv.className = 'song-artist';
                // artistDiv.textContent = song.Artist || '';
                // songInfo.appendChild(artistDiv);
                const titleDiv = document.createElement('div');
                titleDiv.className = 'song-title';
                titleDiv.textContent = song.Title || '';
                songInfo.appendChild(titleDiv);
                
                const artistDiv = document.createElement('div');
                artistDiv.className = 'song-artist';
                artistDiv.textContent = song.Artist || '';
                songInfo.appendChild(artistDiv);
                
                // On mobile, add puzzle piece under artist
                if (window.innerWidth <= 768 && song["Puzzle Piece"]) {
                    const puzzleDiv = document.createElement('div');
                    puzzleDiv.className = 'song-puzzle';
                    puzzleDiv.textContent = song["Puzzle Piece"];
                    songInfo.appendChild(puzzleDiv);
                }
                
                infoCell.appendChild(songInfo);
                row.appendChild(infoCell);
                
                const puzzleCell = document.createElement('td');
                if (window.innerWidth > 768) {
                    puzzleCell.textContent = song["Puzzle Piece"] || '';
                }
                row.appendChild(puzzleCell);
                
                const keyCell = document.createElement('td');
                keyCell.textContent = song.Key || '';
                row.appendChild(keyCell);
                
                tableBody.appendChild(row);
            });
        }

        function showSongDetails(song) {
            sortColumn = null;
            sortDirection = 'asc';
            updateSortIndicators();
            
            const detailCard = document.getElementById('detailCard');
            if (!detailCard) return;
            
            detailCard.classList.remove('hidden');
            
            const notesHTML = convertNotesToLinks(song.Notes);
            
            let cardDisplay = '';
            if (deckManager) {
                const display = deckManager.getSongDisplay(song, currentPlaylist);
                cardDisplay = display.display;
            } else {
                // Fallback
                cardDisplay = `${song.Index} ${song.Card}`;
            }
            
            detailCard.innerHTML = `
                <div class="detail-header">
                    <div class="detail-header-top">
                        <div class="card-symbol">${cardDisplay}</div>
                        <div class="card-title">
                            <h2>${song.Title}</h2>
                            <p>${song.Artist}</p>
                        </div>
                        <div class="card-info">
                            <div>üîë ${song.Key}</div>
                            <div>üìÖ ${song.Date || ''}</div>
                            <div>‚ù§Ô∏è ${song.BPM || ''}</div>
                            <div class="ema-info">ü•Å ${song["Em&a"] || ''}</div>
                        </div>
                    </div>
                </div>
                <div class="detail-content">
                    ${song["Puzzle Piece"] ? `
                        <div class="puzzle-piece">
                            <div class="puzzle-icon">üß©</div>
                            <div>${song["Puzzle Piece"]}</div>
                        </div>
                    ` : ''}
                    ${song["Time Signature"] ? `<p>Time Signature: ${song["Time Signature"]}</p>` : ''}
                    ${notesHTML ? `<div class="notes-links">${notesHTML}</div>` : ''}
                    <div id="documentViewer" class="document-viewer" style="display: none;"></div>
                </div>
            `;
            
            detailCard.scrollIntoView({ behavior: 'smooth' });
        }

        window.addEventListener('resize', () => {
            renderSongTable();
        });

        document.addEventListener('DOMContentLoaded', () => {
            initializeTheme();
            loadSongData();
        });
    </script>
</body>
</html>